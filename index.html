<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Question Editor</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <div class="content">
      <div class="preview-section">
        <h2 class="section-title"><i class="fas fa-edit"></i> Edit Question</h2>

        <div class="editable-group">
          <label class="editable-label">Question:</label>
          <textarea id="questionInput" class="editable-input" enterkeyhint="done" rows="2"></textarea>
        </div>

        <div class="editable-group">
          <label class="editable-label">Answers:</label>
          <ul class="answers-list" id="answersList"></ul>
          <div class="add-answer" id="addAnswerBtn"><i class="fas fa-plus-circle"></i> Add Answer</div>
        </div>

        <div class="editable-group">
          <label class="editable-label">Explanation:</label>
          <textarea id="explanationInput" class="editable-input" enterkeyhint="done" rows="2"></textarea>
        </div>
      </div>

      <div class="info-bar" style="margin-top:10px;">
        <div class="info-item">Question Editor | MOSTAFA ABBAS FADHIL | contact: @al_kaabi33</div>
      </div>
    </div>
  </div>

  <!-- Floating action buttons -->
  <div class="floating-actions" aria-hidden="false">
    <div class="floating-inner">
      <button id="saveBtn" class="btn btn-save"><i class="fas fa-save"></i> Save Changes</button>
      <button id="exitBtn" class="btn btn-exit"><i class="fas fa-sign-out-alt"></i> Exit Editor</button>
    </div>
  </div>

  <script>
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;

    // Utility: parse ?data=... from url and decode JSON
    function parseDataParam() {
      try {
        const params = new URLSearchParams(window.location.search);
        const encoded = params.get('data');
        if (!encoded) return null;
        // If encoded with encodeURIComponent(JSON.stringify(obj))
        const decoded = decodeURIComponent(encoded);
        return JSON.parse(decoded);
      } catch (e) {
        console.warn('Failed to parse data param:', e);
        return null;
      }
    }

    // DOM refs
    const answersList = document.getElementById('answersList');
    const addAnswerBtn = document.getElementById('addAnswerBtn');
    const saveBtn = document.getElementById('saveBtn');
    const exitBtn = document.getElementById('exitBtn');
    const qInput = document.getElementById('questionInput');
    const exInput = document.getElementById('explanationInput');

    // State
    let currentCorrect = null;

    // Resize helper
    function autoResize(el) {
      if (!el) return;
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 240) + 'px';
    }

    // Create answer item
    function createAnswer(value = '', isCorrect = false) {
      const li = document.createElement('li');
      li.className = 'answer-item';
      if (isCorrect) {
        li.classList.add('correct');
      }

      const span = document.createElement('span');
      span.className = 'answer-number';

      const ta = document.createElement('textarea');
      ta.className = 'answer-input';
      ta.rows = 1;
      ta.value = value;
      ta.setAttribute('enterkeyhint', 'done');

      const actions = document.createElement('div');
      actions.className = 'answer-actions';

      const toggle = document.createElement('div');
      toggle.className = 'correct-toggle';
      if (isCorrect) toggle.classList.add('active');
      toggle.innerHTML = '<div class="toggle-handle"></div>';

      const rm = document.createElement('button');
      rm.className = 'remove-answer';
      rm.type = 'button';
      rm.title = 'Remove answer';
      rm.innerHTML = '<i class="fas fa-trash"></i>';

      actions.appendChild(toggle);
      actions.appendChild(rm);
      li.appendChild(span);
      li.appendChild(ta);
      li.appendChild(actions);

      // events for new nodes
      ta.addEventListener('input', () => autoResize(ta));
      ta.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); ta.blur(); } });

      return li;
    }

    // Renumber answers
    function renumber() {
      const items = answersList.children;
      for (let i = 0; i < items.length; i++) {
        const num = items[i].querySelector('.answer-number');
        if (num) num.textContent = i + 1;
      }
    }

    // Remove
    function removeAnswer(li) {
      if (!li) return;
      const wasCorrect = li.classList.contains('correct');
      li.remove();
      if (wasCorrect) currentCorrect = null;
      renumber();
    }

    // Set correct
    function setCorrect(item) {
      if (!item) return;
      if (currentCorrect === item) return;
      if (currentCorrect) {
        currentCorrect.classList.remove('correct');
        const t = currentCorrect.querySelector('.correct-toggle');
        if (t) t.classList.remove('active');
      }
      item.classList.add('correct');
      const t2 = item.querySelector('.correct-toggle');
      if (t2) t2.classList.add('active');
      currentCorrect = item;
    }

    // Event delegation
    answersList.addEventListener('click', (e) => {
      const tgt = e.target;
      if (tgt.closest('.remove-answer')) {
        const li = tgt.closest('.answer-item');
        removeAnswer(li);
        return;
      }
      if (tgt.closest('.correct-toggle')) {
        const li = tgt.closest('.answer-item');
        setCorrect(li);
        return;
      }
    }, { passive: true });

    // Add answer button
    addAnswerBtn.addEventListener('click', () => {
      const li = createAnswer('');
      answersList.appendChild(li);
      renumber();
      const ta = li.querySelector('.answer-input');
      if (ta) { ta.focus(); autoResize(ta); }
    });

    // Populate editor from incoming dict
    function populateFromData(d) {
      if (!d) return;
      qInput.value = d.question || '';
      exInput.value = d.explanation || '';
      // clear existing
      answersList.innerHTML = '';
      const answers = Array.isArray(d.answers) ? d.answers : [];
      // correct_answer may be 0-based or 1-based (try to handle both)
      let correctIndex = typeof d.correct_answer === 'number' ? d.correct_answer : -1;
      if (correctIndex >= 1 && correctIndex <= answers.length) {
        // looks like 1-based -> convert
        correctIndex = correctIndex - 1;
      }
      if (correctIndex < 0 || correctIndex >= answers.length) correctIndex = -1;

      answers.forEach((ans, idx) => {
        const li = createAnswer(ans, idx === correctIndex);
        answersList.appendChild(li);
        if (idx === correctIndex) currentCorrect = li;
      });

      // if no answers provided, initialise 4 empty answers
      if (answers.length === 0) {
        for (let i = 0; i < 4; i++) {
          answersList.appendChild(createAnswer('', i === 0));
        }
        currentCorrect = answersList.children[0];
      }
      renumber();
      // auto-resize all
      answersList.querySelectorAll('.answer-input').forEach(autoResize);
    }

    // Collect data and send back to bot
    async function onSaveClick() {
      const question = qInput.value.trim();
      const explanation = exInput.value.trim();
      const items = answersList.querySelectorAll('.answer-item');
      const answers = [];
      let correctIndex = -1;
      for (let i = 0; i < items.length; i++) {
        const input = items[i].querySelector('.answer-input');
        answers.push(input ? input.value : '');
        if (items[i].classList.contains('correct')) correctIndex = i;
      }

      const data = {
        question,
        answers,
        correct_answer: correctIndex, // 0-based index
        explanation
      };

      // Show quick saved feedback
      const prev = saveBtn.innerHTML;
      saveBtn.disabled = true;
      saveBtn.innerHTML = '<i class="fas fa-check"></i> Saved';

      // send data to bot if inside Telegram
      if (tg && typeof tg.sendData === 'function') {
        try {
          tg.sendData(JSON.stringify(data));
          // close after a small delay to allow send
          setTimeout(() => tg.close(), 250);
        } catch (err) {
          console.error('sendData failed:', err);
          alert('Failed to send data to the bot.');
        }
      } else {
        // Not in Telegram — for local testing just log and show user
        console.log('WebApp send (not in Telegram):', data);
        alert('Running outside Telegram — data printed to console.');
      }

      setTimeout(() => {
        saveBtn.innerHTML = prev;
        saveBtn.disabled = false;
      }, 700);
    }

    // Exit: close the miniapp if possible
    function onExitClick() {
      const prev = exitBtn.innerHTML;
      exitBtn.disabled = true;
      exitBtn.innerHTML = '<i class="fas fa-sign-out-alt"></i> Exiting...';
      setTimeout(() => {
        exitBtn.innerHTML = prev;
        exitBtn.disabled = false;
      }, 600);

      if (tg && typeof tg.close === 'function') {
        tg.close();
      } else {
        // Not in Telegram - maybe just go back or close window
        console.log('Exit clicked (not in Telegram).');
        // window.close() may be blocked in browsers; we won't force-close.
      }
    }

    // wire buttons
    saveBtn.addEventListener('click', onSaveClick);
    exitBtn.addEventListener('click', onExitClick);

    // init on load
    document.addEventListener('DOMContentLoaded', () => {
      // If in Telegram, let the webapp adjust size and signal ready
      if (tg) {
        try { tg.expand(); } catch(e) {}
        try { tg.ready(); } catch(e) {}
      }

      const incoming = parseDataParam();
      populateFromData(incoming);
    });

    // Clean up
    window.addEventListener('beforeunload', () => {
      // nothing heavy to do here
    });
  </script>
</body>
</html>
